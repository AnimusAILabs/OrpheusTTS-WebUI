<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Streaming Audio Playback (Local Development)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    .status { margin: 20px 0; padding: 10px; border-radius: 4px; }
    .controls { margin: 20px 0; }
    button { padding: 8px 16px; margin-right: 10px; }
    #promptInput { width: 100%; margin: 10px 0; }
    #progress { 
      width: 100%; 
      height: 20px; 
      background: #f0f0f0;
      border-radius: 4px;
      margin: 20px 0;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4CAF50;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/howler/2.2.4/howler.min.js"></script>
</head>
<body>
  <h1>Streaming Audio Playback</h1>
  <form id="promptForm">
    <label for="promptInput">Enter Prompt:</label><br>
    <textarea id="promptInput" rows="4" cols="50" placeholder="Type your prompt here" required></textarea><br>
    <button type="submit">Generate Audio</button>
  </form>
  <div class="controls">
    <button id="pauseButton" disabled>Pause</button>
    <button id="resumeButton" disabled>Resume</button>
  </div>
  <div id="status" class="status"></div>
  <div id="progress">
    <div id="progressBar"></div>
  </div>

  <script>
    // Use the RunPod WebSocket URL directly
    const wsUrl = 'wss://zak02hx803s9le-8080.proxy.runpod.net/ws';
    const ws = new WebSocket(wsUrl);
    let isFirstChunk = true;
    let isGenerating = false;
    let sound = null;
    let audioChunks = [];
    let currentBlob = null;
    let hasStartedPlaying = false;
    let lastPlayPosition = 0;
    const MIN_CHUNKS_TO_PLAY = 3;  // Start playing after this many chunks
    let updateInterval = null;

    function showStatus(message) {
      document.getElementById('status').textContent = message;
    }

    function updateProgress(progress) {
      document.getElementById('progressBar').style.width = `${progress}%`;
    }

    // Initialize controls
    const pauseButton = document.getElementById('pauseButton');
    const resumeButton = document.getElementById('resumeButton');
    
    pauseButton.onclick = () => {
      if (sound) {
        sound.pause();
        pauseButton.disabled = true;
        resumeButton.disabled = false;
        showStatus('Playback paused');
      }
    };
    
    resumeButton.onclick = () => {
      if (sound) {
        sound.play();
        pauseButton.disabled = false;
        resumeButton.disabled = true;
        showStatus('Playing audio...');
      }
    };

    function createWavBlob(chunks) {
      // Calculate total audio data length (excluding header from first chunk)
      const totalLength = chunks.reduce((acc, chunk, index) => 
        acc + (index === 0 ? chunk.length - 44 : chunk.length), 0);
      
      // Create combined buffer with header
      const combinedChunks = new Uint8Array(44 + totalLength);
      
      // Write WAV header
      const header = new Uint8Array([
        // RIFF chunk
        0x52, 0x49, 0x46, 0x46, // "RIFF"
        (totalLength + 36) & 0xff, ((totalLength + 36) >> 8) & 0xff, ((totalLength + 36) >> 16) & 0xff, ((totalLength + 36) >> 24) & 0xff, // File size
        0x57, 0x41, 0x56, 0x45, // "WAVE"
        // fmt chunk
        0x66, 0x6d, 0x74, 0x20, // "fmt "
        0x10, 0x00, 0x00, 0x00, // Chunk size: 16
        0x01, 0x00, // Audio format: 1 (PCM)
        0x01, 0x00, // Number of channels: 1
        0x80, 0x5D, 0x00, 0x00, // Sample rate: 24000
        0x00, 0xBB, 0x00, 0x00, // Byte rate: 48000
        0x02, 0x00, // Block align: 2
        0x10, 0x00, // Bits per sample: 16
        // data chunk
        0x64, 0x61, 0x74, 0x61, // "data"
        totalLength & 0xff, (totalLength >> 8) & 0xff, (totalLength >> 16) & 0xff, (totalLength >> 24) & 0xff // Data size
      ]);
      
      combinedChunks.set(header, 0);
      
      // Copy audio data (skipping header from first chunk)
      let offset = 44;
      chunks.forEach((chunk, index) => {
        if (index === 0) {
          combinedChunks.set(chunk.slice(44), offset);
          offset += chunk.length - 44;
        } else {
          combinedChunks.set(chunk, offset);
          offset += chunk.length;
        }
      });
      
      return new Blob([combinedChunks], { type: 'audio/wav' });
    }

    function updateAudio(shouldStartPlaying = false) {
      if (audioChunks.length === 0) return;

      // Store current playback position if sound is playing
      if (sound && sound.playing()) {
        lastPlayPosition = sound.seek();
      }

      // Clean up previous audio
      if (currentBlob) {
        URL.revokeObjectURL(currentBlob);
      }

      const blob = createWavBlob(audioChunks);
      const url = URL.createObjectURL(blob);
      currentBlob = url;

      const wasPlaying = sound && sound.playing();

      if (sound) {
        sound.unload();
      }

      sound = new Howl({
        src: [url],
        format: ['wav'],
        html5: true, // Force HTML5 Audio for streaming
        pool: 1, // Reduce the pool size since we're streaming
        preload: true, // Ensure we preload the audio
        onload: function() {
          // Resume from last position if we were playing
          if (wasPlaying || shouldStartPlaying) {
            this.seek(lastPlayPosition);
            this.play();
          }
        },
        onplay: () => {
          pauseButton.disabled = false;
          resumeButton.disabled = true;
          showStatus('Playing audio...');
        },
        onpause: () => {
          pauseButton.disabled = true;
          resumeButton.disabled = false;
          showStatus('Playback paused');
        },
        onend: () => {
          pauseButton.disabled = true;
          resumeButton.disabled = true;
          showStatus('Playback completed');
          updateProgress(100);
          if (updateInterval) {
            clearInterval(updateInterval);
          }
        },
        onloaderror: (id, err) => {
          console.error('Error loading audio:', err);
          showStatus(`Error loading audio: ${err}`);
          // Try to recover by reducing buffer and restarting
          if (audioChunks.length > MIN_CHUNKS_TO_PLAY) {
            audioChunks = audioChunks.slice(-MIN_CHUNKS_TO_PLAY);
            updateAudio(wasPlaying);
          }
        },
        onplayerror: (id, err) => {
          console.error('Error playing audio:', err);
          showStatus(`Error playing audio: ${err}`);
          // Try to recover by waiting for more chunks
          if (sound) {
            sound.unload();
            sound = null;
          }
        }
      });

      // Update progress
      if (updateInterval) {
        clearInterval(updateInterval);
      }
      
      updateInterval = setInterval(() => {
        if (sound && sound.playing()) {
          const progress = (sound.seek() / sound.duration()) * 100;
          updateProgress(Math.min(100, Math.max(0, progress)));
        }
      }, 100);
    }

    // WebSocket event handlers
    ws.onopen = () => {
      console.log('Connected to RunPod server');
      showStatus('Connected to RunPod server. Click Generate Audio to begin.');
    };

    ws.onclose = () => {
      console.log('Disconnected from RunPod server');
      showStatus('Disconnected from RunPod server');
      if (updateInterval) {
        clearInterval(updateInterval);
      }
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      showStatus('WebSocket error occurred');
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'audio_chunk') {
        const chunk = new Uint8Array(hexToArrayBuffer(data.chunk));
        
        if (isFirstChunk) {
          isFirstChunk = false;
          audioChunks = [chunk];
          // Don't start playing yet, wait for more chunks
          updateAudio(false);
        } else {
          audioChunks.push(chunk);
          // Start playing if we have enough chunks and haven't started yet
          if (!hasStartedPlaying && audioChunks.length >= MIN_CHUNKS_TO_PLAY) {
            hasStartedPlaying = true;
            updateAudio(true);
          } else if (hasStartedPlaying && sound) {
            // Only update audio if we're near the end of the current buffer
            // or if we've accumulated significantly more chunks
            const timeRemaining = sound.duration() - sound.seek();
            if (timeRemaining < 0.5 || audioChunks.length > MIN_CHUNKS_TO_PLAY * 2) {
              updateAudio(true);
            }
          }
        }
      } else if (data.type === 'generation_complete') {
        console.log('Audio generation completed');
        isGenerating = false;
        showStatus('Generation complete');
        // Final update to ensure all audio is included
        updateAudio(hasStartedPlaying);
      }
    };

    // Convert hex string to ArrayBuffer
    function hexToArrayBuffer(hexString) {
      const bytes = new Uint8Array(hexString.length / 2);
      for (let i = 0; i < hexString.length; i += 2) {
        bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
      }
      return bytes.buffer;
    }

    // Form submission handler
    document.getElementById("promptForm").addEventListener("submit", async function(event) {
      event.preventDefault();
      
      if (isGenerating) {
        showStatus('Already generating audio, please wait...');
        return;
      }

      // Reset state
      isFirstChunk = true;
      isGenerating = true;
      hasStartedPlaying = false;
      audioChunks = [];
      updateProgress(0);
      
      if (currentBlob) {
        URL.revokeObjectURL(currentBlob);
        currentBlob = null;
      }
      if (sound) {
        sound.unload();
        sound = null;
      }
      
      // Disable controls initially
      pauseButton.disabled = true;
      resumeButton.disabled = true;
      
      const prompt = document.getElementById("promptInput").value;
      showStatus('Generating audio...');
      
      // Request new audio generation
      ws.send(JSON.stringify({ prompt: prompt }));
    });

    // Clean up when page unloads
    window.addEventListener('beforeunload', () => {
      if (currentBlob) {
        URL.revokeObjectURL(currentBlob);
      }
      if (sound) {
        sound.unload();
      }
    });
  </script>
</body>
</html> 