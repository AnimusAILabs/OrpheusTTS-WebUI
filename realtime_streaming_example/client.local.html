<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Streaming Audio Playback (Local Development)</title>
  <style>
    body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; }
    .status { margin: 20px 0; padding: 10px; border-radius: 4px; }
    .controls { margin: 20px 0; }
    button { padding: 8px 16px; margin-right: 10px; }
    #promptInput { width: 100%; margin: 10px 0; }
    #progress { 
      width: 100%; 
      height: 20px; 
      background: #f0f0f0;
      border-radius: 4px;
      margin: 20px 0;
    }
    #progressBar {
      width: 0%;
      height: 100%;
      background: #4CAF50;
      border-radius: 4px;
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <h1>Streaming Audio Playback</h1>
  <form id="promptForm">
    <label for="promptInput">Enter Prompt:</label><br>
    <textarea id="promptInput" rows="4" cols="50" placeholder="Type your prompt here" required></textarea><br>
    <button type="submit">Generate Audio</button>
  </form>
  <div class="controls">
    <button id="pauseButton" disabled>Pause</button>
    <button id="resumeButton" disabled>Resume</button>
  </div>
  <div id="status" class="status"></div>
  <div id="progress">
    <div id="progressBar"></div>
  </div>

  <script>
    // Use the RunPod WebSocket URL directly
    const wsUrl = 'wss://umukid49349ire-8080.proxy.runpod.net/ws';
    const ws = new WebSocket(wsUrl);
    let audioContext = null;
    let mediaStreamDestination = null;
    let audioQueue = [];
    let isPlaying = false;
    let startTime = 0;
    let totalDuration = 0;
    let processedDuration = 0;

    function showStatus(message) {
      document.getElementById('status').textContent = message;
    }

    function updateProgress(progress) {
      document.getElementById('progressBar').style.width = `${progress}%`;
    }

    // Initialize WebRTC audio context
    function initAudio() {
      if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)({sampleRate: 24000});
        mediaStreamDestination = audioContext.createMediaStreamDestination();
      }
    }

    // Process audio chunks
    function processAudioChunk(chunk) {
      if (!audioContext || !isPlaying) return;

      const buffer = audioContext.createBuffer(1, chunk.length, 24000);
      buffer.copyToChannel(chunk, 0);
      
      const source = audioContext.createBufferSource();
      source.buffer = buffer;
      source.connect(mediaStreamDestination);
      
      const currentTime = audioContext.currentTime;
      source.start(currentTime + processedDuration);
      
      processedDuration += chunk.length / 24000;
      updateProgress((processedDuration / totalDuration) * 100);
    }

    // Initialize controls
    const pauseButton = document.getElementById('pauseButton');
    const resumeButton = document.getElementById('resumeButton');
    
    pauseButton.onclick = () => {
      if (audioContext && isPlaying) {
        audioContext.suspend();
        isPlaying = false;
        pauseButton.disabled = true;
        resumeButton.disabled = false;
        showStatus('Playback paused');
      }
    };
    
    resumeButton.onclick = () => {
      if (audioContext && !isPlaying) {
        audioContext.resume();
        isPlaying = true;
        pauseButton.disabled = false;
        resumeButton.disabled = true;
        showStatus('Playing audio...');
        
        // Process any queued chunks
        while (audioQueue.length > 0) {
          processAudioChunk(audioQueue.shift());
        }
      }
    };

    // WebSocket event handlers
    ws.onopen = () => {
      console.log('Connected to RunPod server');
      showStatus('Connected to RunPod server. Click Generate Audio to begin.');
    };

    ws.onclose = () => {
      console.log('Disconnected from RunPod server');
      showStatus('Disconnected from RunPod server');
    };

    ws.onerror = (error) => {
      console.error('WebSocket error:', error);
      showStatus('WebSocket error occurred');
    };

    ws.onmessage = async (event) => {
      const data = JSON.parse(event.data);
      
      if (data.type === 'audio_chunk') {
        const chunk = new Uint8Array(hexToArrayBuffer(data.chunk));
        
        if (!audioContext) {
          initAudio();
          isPlaying = true;
          pauseButton.disabled = false;
          resumeButton.disabled = true;
          showStatus('Playing audio...');
        }

        try {
          // Convert 16-bit PCM to float32
          const floatData = new Float32Array(chunk.length / 2);
          const view = new DataView(chunk.buffer);
          for (let i = 0; i < floatData.length; i++) {
            floatData[i] = view.getInt16(i * 2, true) / 32768.0;
          }
          
          if (isPlaying) {
            processAudioChunk(floatData);
          } else {
            audioQueue.push(floatData);
          }
        } catch (error) {
          console.error('Error processing audio chunk:', error);
        }
        
      } else if (data.type === 'generation_complete') {
        console.log('Audio generation completed');
        showStatus('Audio streaming completed');
        totalDuration = processedDuration;
      }
    };

    // Convert hex string to ArrayBuffer
    function hexToArrayBuffer(hexString) {
      const bytes = new Uint8Array(hexString.length / 2);
      for (let i = 0; i < hexString.length; i += 2) {
        bytes[i / 2] = parseInt(hexString.substr(i, 2), 16);
      }
      return bytes.buffer;
    }

    // Form submission handler
    document.getElementById("promptForm").addEventListener("submit", async function(event) {
      event.preventDefault();
      
      // Reset state
      if (audioContext) {
        audioContext.suspend();
      }
      audioQueue = [];
      processedDuration = 0;
      totalDuration = 0;
      updateProgress(0);
      
      // Disable controls initially
      pauseButton.disabled = true;
      resumeButton.disabled = true;
      
      const prompt = document.getElementById("promptInput").value;
      showStatus('Generating audio...');
      
      // Request new audio generation
      ws.send(JSON.stringify({ prompt: prompt }));
    });
  </script>
</body>
</html> 